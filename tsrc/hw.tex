
This chapter addresses the hardware architecture. It starts by setting up \textit{Versat} in the IOb-SoC. Then, it describes new Functional Units that are required in order to accelerate the \textit{psycho\_3\_threshold} function. At the end, two hardware accelerators are developed, with each one executing part of the mentioned \textit{TwoLAME} function.

\subsection{Versat}

%checks the \textit{Versat} Functional Units that are available
After measuring the execution times of \textit{TwoLAME} in IOb-SoC, through profiling, it was well-marked that \textit{psycho\_3\_threshold} function needed hardware acceleration, i.e., it should be executed by custom-made hardware. This would bring the possibility to reduce between 37\% to 64\% total execution time, depending on the audio input.
At this stage, the IOb-SoC was comprising eight main components: \textbf{AXI}, \textbf{CACHE}, \textbf{LIB}, \textbf{MEM}, \textbf{VEXRISCV}, \textbf{TWOLAME}, \textbf{UART} and \textbf{TIMER}. Given \textit{Versat} being the optimal choice for accelerating the \textit{psycho\_3\_threshold} function, integration into IOb-SoC becomes imperative.
Therefore, the first step in this process was adding \textbf{VERSAT} to the IOb-SoC. This was simple as \textit{VERSAT} was previously implemented and tested by \textit{IObundle, Lda}. Apart from adding it as submodule to IOb-SoC's repository, some paths were changed to allow correct compilation.
The second step was more complex, consisting in adding an interconnection between \textit{Versat} and RAM. Iob-SoC usually contains a single AXI interface, used by both cache memory and CPU. Considering this, the solution was to double the size of the wires from the already existing AXI interface, providing an additional interface to \textit{Versat} while avoiding a new separate interface.
%explain better

Understanding the resources that \textit{Versat} offers, the subsequent step involves examining the \textit{psycho\_3\_threshold} function.
This function contains three for loops, with the first one being a simple initialization process, setting each element of arrays \textit{LTtm} and \textit{LTnm} to a constant value (\textit{DBMIN}) within the range of 0 to 135 ($SUBSIZE-1$). Performing this initialization in hardware incurs unnecessary overhead, as the result remains constant for all iterations. Instead, in a hardware implementation, we can directly use the constant value DBMIN as an input for the subsequent hardware operations (the next for loops, in this case), optimizing efficiency and reducing the need for a dedicated initialization loop.
Therefore, only two accelerators should be developed in order to execute the second and third for loops of \textit{psycho\_3\_threshold}.

The third for loop is simple as it just includes the \textit{psycho\_3\_add\_db} function. 
On the opposite, the second for loop is not only complex but it is also more interesting. The main for loop (outer loop) contains two \textit{if} conditions and, inside each condition, there is another for loop (inner loop). Moreover, the inner loop is the same in both conditions, differing only on part of the input data. This means that it is only necessary to develop hardware that executes both inner loops, with the if conditions and the outer loop being handled by the CPU.

\subsubsection{Functional units}
\textit{Versat} gives the user the possibility to create and add new Functional units to the source. In this work, five FUs were specifically designed to allow accelerating \textit{psycho\_3\_threshold} function, such as \textit{FloatLess}, \textit{FloatGreater}, \textit{FloatGreaterEqual}, \textit{Mux4} and \textit{Conditional1}.

A brief description of each functional unit is provided in the table below.

\vspace{0.5cm}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|p{0.8\linewidth}|}
        \hline
        \multicolumn{1}{|c|}{\textbf{FU}} & \multicolumn{1}{c|}{\textbf{Description}} \\
        \hline
        \multirow{6}{*}{\textit{FloatLess}} & This module receives two 32-bit floating-point inputs and outputs a 32-bit value (repeated 1-bit result result 32 times) indicating whether the first input is less than the second. It performs a comparison operation to determine if the first input is less than the second. If the first input is less than the second, the output will be a 32-bit value with all bits set to 1; otherwise, the output will be a 32-bit value with all bits set to 0.  \\
        \hline
        \multirow{6}{*}{\textit{FloatGreater}} & This module receives two 32-bit floating-point inputs and outputs a 32-bit value (repeated 1-bit result 32 times) indicating whether the first input is greater than the second. It performs a comparison operation to determine if the first input is greater than the second. If the first input is greater than the second, the output will be a 32-bit value with all bits set to 1; otherwise, the output will be a 32-bit value with all bits set to 0. \\
        \hline
        \multirow{6}{*}{\textit{FloatGreaterEqual}} & This module receives two 32-bit floating-point inputs and outputs a 32-bit value (repeated 1-bit result 32 times) indicating whether the first input is greater than or equal to the second. It performs a comparison operation to determine if the first input is greater than or equal to the second. If the first input is greater than or equal to the second, the output will be a 32-bit value with all bits set to 1; otherwise, the output will be a 32-bit value with all bits set to 0. \\
        \hline
        \multirow{5}{*}{\textit{Mux4}} & This module receives four 32-bit inputs and one 32-bit control input. It operates as a 4-to-1 multiplexer, selecting one of the 32-bit inputs based on the two least significant bits (LSB) of the control input.  The two LSB of the control input can be '00', '01', '10' or '11', selecting the first, the second, the third or the fourth input, respectively. The output will be the 32-bit input that was selected. \\
        \hline
        \multirow{4}{*}{\textit{Conditional1}} & This module receives two 32-bit inputs and one 32-bit control input. It operates as a 2-to-1 multiplexer, selecting one of the 32-bit inputs based on the 32-bit control input. If the LSB of the control input is zero, the output will be the second 32-bit input; otherwise, the output will be the first 32-bit input. \\
        \hline
    \end{tabular}
    \caption{Table of functional units.}
    \label{tab:fu}
\end{table}

\vspace{0.5cm}

Concerning hardware acceleration, a crucial step is to determine the control and data paths of the software that is intended to be accelerated. In other words, the paths refers to the fundamental components that dictate how the software interacts with the hardware to achieve acceleration.

The control path defines the flow and sequencing of operations within the software that needs to be accelerated. It includes decisions, branching, loops, and other control structures that determine the program's behavior. Determining the control path is vital for optimizing the hardware design to efficiently execute these operations.
The data path refers to the route through which data flows within the software during its execution. It involves operations and transformations applied to the input data to produce the desired output. Understanding the data path is crucial for designing hardware components that can process and manipulate the data effectively to accelerate the software's performance.

Considering this, optimizing both the control and data paths is essential to develop an efficient hardware design that aligns with the software's requirements.

\subsection{\textit{spectrum\_search} accelerator}

\subsubsection{Control and Data paths}
This section shows both control and data paths of the first accelerator, \textit{spectrum\_search}, corresponding to the second for loop in \textit{psycho\_3\_threshold} function.

\begin{figure}[H]
\centerline{\fbox{\includegraphics[width=0.90\linewidth]{first.pdf}}}
\caption{Control and data paths of the \textit{spectrum\_search} hardware accelerator.}
\label{data1}
\end{figure}

\subsubsection{Modules}
After analysing the control and data paths, the hardware accelerator is developed in \textit{versatSpec.txt}. This file specifies the whole data process, which can be divided in several modules each representing a certain functionality or output. The starting module is called \textit{start} and invokes all the other modules.

A brief description of each module is provided in the list below.

\vspace{0.5cm}

\textit{\textbf{av}}

\begin{enumerate}

\item Float multiplication (\textit{mul1}):
\begin{itemize}
\item Takes \textit{const2} and \textit{bark} as inputs.
\item Multiplies \textit{const2} and \textit{bark}.
\end{itemize}

\item Float addition (\textit{add1}):
\begin{itemize}
\item Takes the output of \textit{mul1} and \textit{const1} as inputs.
\item Adds \textit{mul1} and \textit{const1}.
\end{itemize}

\item Float addition (\textit{add2}):
\begin{itemize}
\item Takes the output of \textit{add1} and \textit{Xtm} as inputs.
\item Adds \textit{add1} and \textit{Xtm}.
\end{itemize}

\item Float addition (\textit{add3}):
\begin{itemize}
\item Takes the output of \textit{add2} and \textit{const3} as inputs.
\item Adds \textit{add2} and \textit{const3}.
\end{itemize}

\item Output (\textit{out}):
\begin{itemize}
\item Takes the output of \textit{add3} as the final output of this module.
\end{itemize}

\end{enumerate}

\vspace{0.5cm}

\textit{\textbf{dzRange}}

\begin{enumerate}

\item Greater or equal comparison (\textit{ge1\_dzRange}):
\begin{itemize}
\item Compares the input \textit{dz} with \textit{const1\_dzRange} for greater than or equal condition.
\end{itemize}

\item Less than comparison (\textit{lt1\_dzRange}):
\begin{itemize}
\item Compares the input \textit{dz} with \textit{const2\_dzRange} for less than condition.
\end{itemize}

\item Logical AND operation (\textit{and}):
\begin{itemize}
\item Performs a logical AND operation on the outputs of \textit{ge1\_dzRange} and \textit{lt1\_dzRange}.
\end{itemize}

\item Output (\textit{out}):
\begin{itemize}
\item Takes the output of \textit{and} as the final output of this module.
\end{itemize}

\end{enumerate}

\vspace{0.5cm}

\textbf{\textit{Logic}}

\begin{enumerate}

\item Less than comparison (\textit{lt1\_Logic}, \textit{lt2\_Logic}, \textit{lt3\_Logic}):
\begin{itemize}
\item Compares the input \textit{dz} with \textit{const1\_Logic}, \textit{const2\_Logic} and \textit{const3\_Logic} for less than conditions.
\end{itemize}

\item Bitwise NOT, AND and Shift Left operations:
\begin{itemize}
\item Performs bitwise NOT, AND and Shift Left operations with the previous outputs to calculate \textit{one}.
\end{itemize}

\item Bitwise AND, OR, and Shift Left operations:
\begin{itemize}
\item Performs bitwise AND, OR, and Shift Left operations with the previous outputs to calculate \textit{zero}.
\end{itemize}

\item Bitwise XOR operation (\textit{sel}):
\begin{itemize}
\item Combines the previous outputs using bitwise XOR to obtain the final selection.
\end{itemize}

\item Output (\textit{out}):
\begin{itemize}
\item Takes the output of \textit{sel} as the final output of this module.
\end{itemize}

\end{enumerate}

\vspace{0.5cm}

\textbf{\textit{vf4}}

\begin{enumerate}

\item Calculation of $0.4 * Xtm + 6$:
\begin{itemize}
\item Multiplies \textit{Xtm} by \textit{const3\_vf4}.
\item Adds \textit{const4\_vf4} to the result.
\end{itemize}

\item Calculation of  $17 * (dz + 1) - (0.4 * Xtm + 6)$:
\begin{itemize}
\item Adds 1 to the input \textit{dz}.
\item Multiplies the result by \textit{const1\_vf4}.
\item Subtracts the output of step 1 from the previous result.
\end{itemize}

\item Calculation of  $(0.4 * Xtm + 6) * dz$:
\begin{itemize}
\item Multiplies the output of step 1 by the input \textit{dz}.
\end{itemize}

\item Calculation of  $-17 * dz$:
\begin{itemize}
\item Multiplies the input \textit{dz} by \textit{const5\_vf4}.
\end{itemize}

\item Calculation of  $-(dz - 1) * (17 - 0.15 * Xtm) - 17$:
\begin{itemize}
\item Subtracts 1 from the input \textit{dz}.
\item Multiplies the previous result by \textit{const6\_vf4}.
\item Multiplies \textit{Xtm} by \textit{const1\_vf4}.
\item Subtracts the output of step 5 from the previous result.
\end{itemize}

\item Conditional selection based on \textit{logic1}:
\begin{itemize}
\item Uses a multiplexer \textit{mux4\_vf4} to select one of the previous outputs based on the input \textit{logic1}.
\end{itemize}

\item Output (\textit{out}):
\begin{itemize}
\item Takes the output of \textit{mux4\_vf4} as the final output of this module.
\end{itemize}

\end{enumerate}

\vspace{0.5cm}

\textbf{\textit{psycho\_3\_add\_db}}

\begin{enumerate}

\item Input multiplexing (\textit{mux4\_psycho\_3}):
\begin{itemize}
\item Uses a multiplexer to select one of the inputs (\textit{a}, \textit{b}, \textit{add1}, \textit{add2}) based on the selection signal \textit{sel}.
\end{itemize}

\item Conditional selection using if condition (\textit{conditional\_psycho\_3}):
\begin{itemize}
\item Uses a conditional block to select \textit{a} or the output of \textit{mux4\_psycho\_3} based on the input \textit{if}.
\end{itemize}

\item Output (\textit{out}):
\begin{itemize}
\item Takes the output of \textit{conditional\_psycho\_3} as the final output of this module.
\end{itemize}

\end{enumerate}

\vspace{0.5cm}

\textbf{\textit{start}}

This is the main module, which is responsible for invoking all the other modules. It interconnects all modules by defining the correct inputs and outputs, apart from executing simple logical operations.


\subsubsection{Firmware}
Apart from specifying the data process, configuring all the input data for the hardware accelerator is also required. The inputs can either be simple constants or data arrays that are streamed by a memory unit, sequentially. The inputs can also be stored in a memory unit and accessed randomly.

As mentioned in the \textit{psycho\_3\_threshold} function section, the first accelerator executes both inner loops in the second for loop of \textit{psycho\_3\_threshold}.
Therefore, this accelerator executes several runs, i.e. there is the need to configure the accelerator with at least two sets of input data.
This is done in two separate functions because part of the data configuration is valid for all the runs. Part of the configuration that doesn't change (between runs) belongs to the \textit{initVersat} function, while the remaining part belongs to \textit{configureVersat} function.

In \textit{initVersat} the constants (that don't change between runs) are configured by assigning the intended value to the constant name (from the hardware accelerator). For floating-point data the \textit{PackInt} function is required, which receives the intended value as argument.
There is also a memory unit configuration for \textit{freq\_subset} array. This sets an internal memory with each position of the array, from 0 to SUBSIZE, read by the CPU through \textit{VersatUnitWrite} function, sequentially.
There are also two memory unit configurations for \textit{bark} and \textit{mem}$\rightarrow$\textit{dbtable} arrays. These set two lookup tables, with SUBSIZE and HBLKSIZE, respectively.

In \textit{configureVersat} four constants are configured as they differ between runs. An input of \textit{mux2} multiplexer is also configured based on a flag that is handled by the CPU.
At this point, all the input data is set for the hardware accelerator, and so it starts the execution through \textit{RunAccelerator} functions. This function receives as argument the number of times that the accelerator should run with the exact same configuration, which is 1.


\subsection{\textit{masking\_threshold} accelerator}

\subsubsection{Control and Data paths}
This section shows both control and data paths of the second accelerator, \textit{masking\_threshold}, corresponding to the third for loop in \textit{psycho\_3\_threshold} function.

\begin{figure}[H]
\centerline{\fbox{\includegraphics[width=0.95\linewidth]{second.pdf}}}
\caption{Control and data paths of the \textit{masking\_threshold} hardware accelerator.}
\label{data2}
\end{figure}

\subsubsection{Modules}

\vspace{0.5cm}

\textbf{\textit{psycho\_3\_add\_db\_V1}}

\begin{enumerate}

\item Input Multiplexing (\textit{mux4\_psycho\_3}):
\begin{itemize}
\item Uses a multiplexer \textit{mux4\_psycho\_3} to select one of the inputs (\textit{a}, \textit{b}, \textit{add1}, \textit{add2}) based on the selection signal \textit{sel}.
\end{itemize}

\item Output Selection (out):
\begin{itemize}
\item Takes the output of \textit{mux4\_psycho\_3} as the final output of this module. The selected input is determined by the value of \textit{sel}.
\end{itemize}

\end{enumerate}

\vspace{0.5cm}

\textbf{\textit{start1}}

This module has some similarity with the \textit{start} module of the first accelerator, since it contains most of the \textit{start} module description but duplicated.
It invokes and interconnects all the other modules, apart from executing simple logical and conditional operations.

\subsubsection{Firmware}

As mentioned in the \textit{psycho\_3\_threshold} function section, the second accelerator executes the third for loop of \textit{psycho\_3\_threshold}.
The configuration of this accelerator is done inside a single function, since it performs only one run. Therefore, all the configuration belongs to \textit{configureVersat1} function.

In this function, the process is similar to the previous configuration function, since the second accelerator does not contain any functional unit that is not present in the first accelerator.
